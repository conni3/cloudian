
[{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/tags/calas/","section":"Tags","summary":"","title":"Calas","type":"tags"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/","section":"Cloudian","summary":"","title":"Cloudian","type":"page"},{"content":" Motivation for the internship: # I am passionate about forging a career in research and innovation within computer engineering. This internship offers a unique opportunity to translate my theoretical knowledge into hands-on expertise by designing and building a processor from the ground up. Though Iâ€™ve enjoyed studying digital logic circuits, Iâ€™ve noticed that much of what I learned has faded over timeâ€”and Iâ€™m determined to refresh and deepen those fundamentals.\nBeyond simply revisiting FPGA workflows, Iâ€™m excited to explore computer architecture in depthâ€”an area I havenâ€™t yet had formal coursework in, despite it being central to my degree. By guiding a design through every stageâ€”from HDL simulation to on-board testingâ€”I aim to:\nMaster FPGA toolchains and digital-logic design\nBuild a solid understanding of RISC-V instruction set and datapath organization\nBridge the gap between abstract concepts and real hardware implementation\nCultivate the confidence and skills I need to grow each day as a researcher\nUltimately, I believe this hands-on experience will be the cornerstone of my journey toward becoming the kind of engineer and researcher I aspire to be.\nTimeline # Weeks 1-3 FPGA design # Week 1: Environment \u0026amp; Basics # Setting up Vitis Review Verilog syntax and some combinational circuits Building testbench for simulation Week 2: Core modules # Design and verify an n-bit ALU (add, subtract and logic operations) Implement a simple register file Integrate ALU + simple register file Week 3: Synthesis and Testing on board # Synthesize the design on PYNQ-Z2 Write constraints Load the bitstream and run I/O tests Document timing results and resource utilization Weeks 4-6 Computer architecture # Week 4: Instruction set architecture # Read up on ISA concepts (RISC vs CISC, datapath components) Explore the RISC-V base spec Draw a simplified datapath diagram Week 5: Pipelining \u0026amp; Control # Learn pipeline stages and hazards Simulate a 5-stage pipeline in software Implement hazard detection \u0026amp; forwarding logic on paper Week 6: Memory \u0026amp; I/O # Study memory hierarchy (registers, cache, main memory) Model a cache in simulation (measure hit/miss rates) Review basic I/O interfacing (memory vs port mapped) Weeks 7-9 Implementing RISC V architecture # Week 7: Core Integer Pipeline # Translate the simulated pipeline into HDL modules Implement fetch-decode-execute stages in Verilog Week 8: Completing the Pipeline # Add MEM and WB stages; integrate control signals Test a small instruction sequence on the FPGA Week 9: Extensions and Testing # Implement branches and simple control/status registers Develop a test suite Measure and document performance Weeks 10-12 Improvement and Further Research # Week 10: Optimization # Add hazard reduction features (branch prediction, deeper pipelines) Profile performance improvements Week 11: Advanced Features # Explore floating-point or vector extensions Prototype an exception/interrupt handler Week 12: Documentation and Demo # Prepare a design report Recording a demo of the processor Identify open questions for future work ","date":"20 May 2025","externalUrl":null,"permalink":"/posts/internship-timeline/","section":"Posts","summary":"Motivation for the internship: # I am passionate about forging a career in research and innovation within computer engineering. This internship offers a unique opportunity to translate my theoretical knowledge into hands-on expertise by designing and building a processor from the ground up.","title":"Internship Timeline","type":"posts"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/tags/learning_log/","section":"Tags","summary":"","title":"Learning_log","type":"tags"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"This is where I will update my daily progress and activities.\n","date":"19 May 2025","externalUrl":null,"permalink":"/posts/learning-logs/","section":"Posts","summary":"This is where I will update my daily progress and activities.","title":"Learning Logs","type":"posts"},{"content":" Week 1 Learning Log (May 19â€“23, 2025) # 1. Objectives # Grasp FPGA internal architecture: CLBs, LUTs, and on-chip SRAM/Block RAM Install and configure Vivado/Vitis on Windows Implement and simulate basic arithmetic primitives: Half Adder (half_adder.v) Full Adder (full_adder.v) 4-bit Carry Propagation Adder (prop_adder) 2. Daily Activities # ðŸ“… Mon, May 19 # Reviewed FPGA architecture:\nCLB = LUT + multiplexer + flip-flops + block RAM (SRAM-based)\nAlso looked at programmable interconnects.\nCreated internship timeline\nðŸ“… Tue, May 20 # Downloaded and ran AMD Unified Installer (Vivado \u0026amp; Vitis 2022.2)\nConfigured WebPACK license and environment\nðŸ“… Wed, May 21 # Wrote half_adder.v and testbench Half_Adder_tb.v\nRan behavioral simulation in XSim to verify sum/carry truth table\nðŸ“… Thu, May 22 # Imported half_adder into new project\nAdded full_adder.v and Full_Adder_tb.v\nSimulated full-adder behavior\nExtended to 4-bit prop_adder using IP Integrator\nðŸ“… Fri, May 23 # Ran synthesis for all designs\nAnalyzed LUT utilization and CLB mapping\nWrote blog posts on:\nSRAMs (how cells store truth tables)\nBistable Flip-Flops\nLUTs\n3. Key Learnings # Configurable Logic Block (CLB): core building block comprising LUTs, muxes, flip-flops for implementing user logic Look-Up Tables (LUTs): small SRAM-based memory (e.g., 4- to 6-input) that encodes combinational logic; viewed utilization post-synthesis Block RAM (SRAM): larger on-chip SRAM blocks for data storage/state machines within designs Vivado Flow: project setup â†’ HDL source \u0026amp; test-bench creation â†’ simulation (XSim) â†’ synthesis/implementation â†’ bitstream generation Arithmetic Modules: Half Adder: sum = a ^ b, carry = a \u0026amp; b Full Adder: cascaded half-adders with carry-in/out 4-bit Carry Propagation Adder: chain of four full-adder blocks (prop_adder) 4. Next Steps (Week 2) # Test hardware on Zedboard: program bitstreams for half, full, and prop_adder designs Dive into Vivado IP Integrator: automate block-design for multi-bit adders Begin drafting a simple ALU control module and integrate adders ","date":"19 May 2025","externalUrl":null,"permalink":"/posts/learning-logs/week-1/","section":"Posts","summary":"Week 1 Learning Log (May 19â€“23, 2025) # 1. Objectives # Grasp FPGA internal architecture: CLBs, LUTs, and on-chip SRAM/Block RAM Install and configure Vivado/Vitis on Windows Implement and simulate basic arithmetic primitives: Half Adder (half_adder.","title":"Week 1","type":"posts"},{"content":"","date":"13 June 2022","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":" At the heart of an SRAM cell lies a bistable flip-flop, which is a circuit capable of holding one of two stable states: logic \u0026lsquo;0\u0026rsquo; or logic \u0026lsquo;1\u0026rsquo;. This flip-flop is typically constructed using two cross-coupled inverters\nHow Cross-Coupled Inverters Form a Flip-Flop # A flip-flop is a circuit with two stable states, capable of storing one bit of information. In SRAM, this is achieved by connecting two inverters in a loop:\nInverter A: Takes input from the output of Inverter B.\nInverter B: Takes input from the output of Inverter A.\nThis cross-coupling creates a feedback loop where the output of each inverter reinforces the input of the other. As a result, the circuit stabilizes in one of two states:\nState 1: Output of Inverter A is \u0026lsquo;1\u0026rsquo;; Output of Inverter B is \u0026lsquo;0\u0026rsquo;.\nState 2: Output of Inverter A is \u0026lsquo;0\u0026rsquo;; Output of Inverter B is \u0026lsquo;1\u0026rsquo;.\nThese two stable states correspond to the stored bit being \u0026lsquo;1\u0026rsquo; or \u0026lsquo;0\u0026rsquo;, respectively.\nHow Transistors form an inverter # A CMOS (Complementary Metal-Oxide-Semiconductor) inverter consists of two types of transistors:\nPMOS (P-type MOSFET): Conducts when the gate voltage is low.\nNMOS (N-type MOSFET): Conducts when the gate voltage is high.\nThese transistors are connected in a specific configuration:\nPMOS Transistor:\nSource connected to the positive supply voltage (VDD).\nDrain connected to the output node.\nGate connected to the input signal.\nNMOS Transistor:\nSource connected to ground (GND).\nDrain connected to the output node.\nGate connected to the input signal.\nThe gates of both transistors are tied together and serve as the input, while their drains are connected together to form the output.\nOperation:\nInput Low (0V):\nPMOS is ON (conducting), NMOS is OFF (non-conducting).\nOutput is pulled up to VDD (logic high).\nInput High (VDD):\nPMOS is OFF (non-conducting), NMOS is ON (conducting).\nOutput is pulled down to GND (logic low).\nThis configuration ensures that the output is always the logical inverse of the input, hence functioning as an inverter.\n","externalUrl":null,"permalink":"/posts/digital-logic-circuits/bistable-flip-flop/","section":"Posts","summary":"At the heart of an SRAM cell lies a bistable flip-flop, which is a circuit capable of holding one of two stable states: logic \u0026lsquo;0\u0026rsquo; or logic \u0026lsquo;1\u0026rsquo;. This flip-flop is typically constructed using two cross-coupled inverters","title":"Bi-stable Flip Flop","type":"posts"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"This is where I will be adding entries on theories and concepts I learned along the way and would like to look back and reference.\n","externalUrl":null,"permalink":"/posts/digital-logic-circuits/","section":"Posts","summary":"This is where I will be adding entries on theories and concepts I learned along the way and would like to look back and reference.","title":"Digital Logic Circuits","type":"posts"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"Fills 2 needs:\ndirect interface with CPU at speeds not attainable by [[Content/CALAS/Theories/DRAM|DRAM]]s replace DRAMs in systems with very low power consumption In 1st use, SRAM serves as cache memory, interfacing between DRAMs and the CPU ![Pasted image 20250524194226](assets/posts/Pasted image 20250524194226.png)\nFor 2nd use, SRAM is used instead of DRAM. This is because DRAM refresh current is several orders of magnitude more than the low-power SRAM standby current.\nAccess time is comparable to DRAMs in low power mode.\nHow it works # ![Pasted image 20250524221931](assets/posts/Pasted image 20250524221931.png) Consists of [[bistable flip flop|bi-stable flip flop]]s connected to the internal circuity by two access transistors.\nIt has 3 states:\nIdle State When not addressed, the access transistors are off and flip flops maintain their state, preserving the stored data. Read Operation Activating the world line turns on the access transistors, connecting the flip flops to bit lines. Sense amplifiers detect the logic level and transfer it to the output. Write operation Data from the input is driven onto the bit lines, overriding the existing state due to stronger write drivers. Compared to [[Content/CALAS/Theories/DRAM|DRAM]], SRAM only needs power supply for stable data.\nTypes # 4T Cell Four NMOS transistors with two poly load resistors 6T Cell Four NMOS and two PMOS transistors, (better stability and performance) TFT Cell Utilizes thin-film transistors (often used in applications like display technologies) Applications: # Cache memory: L1 and L2 caches in CPUs Storage buffers: Temporary storage in storage devices Industrial and Peripheral buffers: Networking equipment and other peripherals References: https://web.eecs.umich.edu/~prabal/teaching/eecs373-f11/readings/sram-technology.pdf\n","externalUrl":null,"permalink":"/posts/digital-logic-circuits/sram/","section":"Posts","summary":"Fills 2 needs:\ndirect interface with CPU at speeds not attainable by [[Content/CALAS/Theories/DRAM|DRAM]]s replace DRAMs in systems with very low power consumption In 1st use, SRAM serves as cache memory, interfacing between DRAMs and the CPU !","title":"SRAM","type":"posts"},{"content":"","externalUrl":null,"permalink":"/tags/theory/","section":"Tags","summary":"","title":"Theory","type":"tags"}]